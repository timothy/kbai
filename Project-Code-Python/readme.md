# FIRST TRY LOGIC	
## 1 All the same
If all shapes in the sequence are the same then the answer is probably the same. Choose the one that is the same as the first in the sequence. This seemed like a very simple idea so I thought it would be easy. The first problem I ran into was with using ImageChops.difference(a, b).getbbox(). It was saying that both images were the same when clearly they were different. I found that when splitting each image into their channels the Red, Green, and Blue channels all showed an image but for some reason, the 4th was blank wite. The 4th channel was acting like the alpha channel. ImageChops.difference(a, b).getbbox() was comparing the alpha channels and saying all the images were the same. I fixed this problem by adding .convert('RGB') when opening them. This way they will for sure compare the shapes and not the blank white canvas.
## 2 Reflection
It was smooth sailing for a bit until I hit the reflection logic. When I reflected the images they looked identical to me but when I did a diff on them they were a few pixels off from each other. This is where Numpy came in handy. I used it to see what percentage of pixels in the two images were the same. I did np.mean(a_reflection == b) and it came out to something like ~99% the same. So I created a method called close_enough. If the value of the two images were equal or above 98% the same then they are close enough and I consider them the same. I decided to add a method to check if C is a reflection of A. This works the same as the “if B is a reflection of A” method only difference is C is switched out for B. When doing this I noticed that Basic Problem B-06 should have been solved by this method but was not. I compared the two images “reflection of A” and B. They were only ~95% the same. So I lowered my close_enough() comparison function to accept images as the same if they were greater than or equal to 95% the same. After this a few other answers became correct this brought me up to a total of 8 correct answers.
## 3 Rotated Image
After building the reflection methodology I noticed that two of the images that were labeled incorrect could be solved by identifying patterns in the rotation of the image. I thought that this would be a good next step in my thinking pipeline.
## 4 Horizontal and Vertical
I started out by looking at answers “horizontal” i.e.  A is to B as C is to X. This thinking got me close but then I realized the possibilities of “Vertical” truths i.e. A is to C as B is to X. I went back and added this logic as a back-up for a method that could not find an answer. I kept to the pattern of creating a vertical for every horizontal or vice versa.
## 5 Difference percentage: A is to B as C is to X
I realized that some answers could be solved using a percentage of telling how different one image is from another image. E.g. if A’s pixels are 28% the same as B’s pixels then look for C that is ~28% the same as X. This method in the thinking pipeline was surprisingly successful! Just by itself it got 8 out of 12 right. Not only did the images I thought it would solve come back with the right answer but it solved other problems I did not think it would solve. This also led me to think this may have the potential to give false positives. It does not work on problems like Basic Problem 4 or 7. This is because they are all the same percentage. Because of the way this works it will have to go after the reflection and rotation methods in the thinking pipeline.
## 6 A filled is B
This is easy to think about and solve for humans. When filling a hollowed version of A is the same as B then look for a filled version of C. At first this problem stumped me. I asked myself “how do I distinguish the white background in the middle of the image from the white background outside the image?” My first thought was to use geometry to “find the point in the polygon” and then flood fill. After thinking about it for a bit I decided to check online for any solution that would be easier than what I was thinking. Sure enough, someone brilliant knew that if you flood-fill the 0,0 position of the image with non-wite/black color then convert all remaining white to black then convert back the color to white it will in essence fill the image to solid black. Thank you Stack Overflow! After I figured out how to fill the hallowed images it was relatively easy to solve this problem using the existing helper methods I built while solving the other problems. While it is necessary to have this thought in the pipeline it is too easy for it to give off a false positive. I decided this needs to be the last thought in the thinking pipeline. 
